use embedded_svc::{
    http::{Headers, Method},
    io::{Read, Write},
};
use esp_idf_hal::{gpio::PinDriver, prelude::Peripherals};
use esp_idf_svc::http::server::{Configuration, EspHttpServer};
use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
use log::*;
use max7219::*;
use serde::Serialize;
use std::{
    str,
    sync::{Arc, Mutex},
    time::Instant,
};

mod led;
use led::{RGB8, WS2812RMT};

mod display;
use display::{DotDisplay, Ticker};

mod wifi;
use wifi::Wifi;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> anyhow::Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_sys::link_patches();
    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();
    let peripherals = Peripherals::take().unwrap();

    // The constant CONFIG is auto-generated by toml_config
    let app_config = CONFIG;
    let mut led = WS2812RMT::new(peripherals.pins.gpio18, peripherals.rmt.channel0)?;

    // Associate to network and obtain DHCP IP
    info!(
        "Loading with credentials, ssid:{:?} psk:{:?}",
        app_config.wifi_ssid, app_config.wifi_psk
    );
    let mut wifi = Wifi::init(peripherals.modem, app_config.wifi_ssid, app_config.wifi_psk)?;

    // Setup for the Ticker display
    let data = PinDriver::output(peripherals.pins.gpio0)?;
    let cs = PinDriver::output(peripherals.pins.gpio1)?;
    let sck = PinDriver::output(peripherals.pins.gpio2)?;
    let ticker = Arc::new(Mutex::new(Ticker::new(DotDisplay::from(
        MAX7219::from_pins(1, data, cs, sck).unwrap(),
    )?)));

    // Set up the HttpServer
    let mut server = EspHttpServer::new(&Configuration::default())?;

    let t_get_handler = ticker.clone();
    server.fn_handler("/", Method::Get, move |req| {
        let t = t_get_handler.lock()?;

        #[derive(Serialize)]
        struct TickerConfig {
            message: String,
            speed: u32,
            brightness: u8,
        }

        let config = TickerConfig {
            speed: t.speed_ms as u32,
            message: t
                .message
                .iter()
                .map(|&c| c as char)
                .take(t.message_len)
                .collect(),
            brightness: t.display.brightness() as u8,
        };

        let mut response = req.into_ok_response()?;
        response.write_all(serde_json::to_string(&config)?.as_bytes())?;
        Ok(())
    })?;

    let t_speed_handler = ticker.clone();
    server.fn_handler("/speed", Method::Put, move |mut req| {
        let len = req.content_len().unwrap_or(0) as usize;
        let mut buf = vec![0; len];
        req.read_exact(&mut buf)?;

        let speed = str::from_utf8(&buf)?.parse::<usize>()?;
        t_speed_handler.lock()?.speed_ms = speed;

        info!("Set scroll speed to {:?}ms", speed);
        req.into_ok_response()?;
        Ok(())
    })?;

    let t_brighness_handler = ticker.clone();
    server.fn_handler("/brightness", Method::Put, move |mut req| {
        let len = req.content_len().unwrap_or(0) as usize;
        let mut buf = vec![0; len];
        req.read_exact(&mut buf)?;

        t_brighness_handler
            .lock()?
            .display
            .set_brightness(str::from_utf8(&buf)?.parse::<u8>()?)?;
        req.into_ok_response()?;
        Ok(())
    })?;

    let t_message_handler = ticker.clone();
    server.fn_handler("/message", Method::Put, move |mut req| {
        let len = req.content_len().unwrap_or(0) as usize;
        let mut buf = vec![0; len];
        req.read_exact(&mut buf)?;

        t_message_handler
            .lock()?
            .set_message(str::from_utf8(&buf)?)?;
        req.into_ok_response()?;
        Ok(())
    })?;

    // Start wifi driver and loop here until STA iface is up and connected
    led.set_pixel(RGB8::new(100, 0, 0))?;
    wifi.start()?;
    loop {
        if wifi.connect_and_wait().is_ok() {
            break;
        }
    }

    // Now connected
    let mut was_connected = true;
    led.set_pixel(RGB8::new(0, 100, 0))?;
    if let Ok(mut t) = ticker.lock() {
        t.display.set_brightness(80)?;
        t.set_message(&format!(
            "{:?}",
            wifi.driver.wifi().sta_netif().get_ip_info()?.ip
        ))?;
    }

    let mut connection_lost_at = None;
    loop {
        if wifi.is_up() {
            if !was_connected {
                // Connected again
                led.set_pixel(RGB8::new(0, 100, 0))?;
                was_connected = true;
                connection_lost_at = None;
                info!(
                    "Reestablished connection: {:?}",
                    wifi.driver.wifi().sta_netif().get_ip_info()?.ip
                );
            }
        } else if was_connected
            || connection_lost_at
                .is_some_and(|c| Instant::now().duration_since(c).as_secs() > 30)
        {
            // Lost connection, or too much time has passed since last attempt at 'connect'
            connection_lost_at = Some(Instant::now());
            was_connected = false;
            wifi.driver.wifi_mut().connect()?;
            led.set_pixel(RGB8::new(100, 0, 0))?;
            info!("Connection lost... scanning");
        }

        if let Ok(mut t) = ticker.lock() {
            t.tick();

            std::thread::sleep(std::time::Duration::from_millis(t.speed_ms as u64));
        }
    }
}
