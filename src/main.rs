use embedded_svc::{
    http::{Headers, Method},
    io::{Read, Write},
};
use esp_idf_hal::{gpio::PinDriver, prelude::Peripherals};
use esp_idf_svc::http::server::{Configuration, EspHttpServer};
use esp_idf_sys as _; // If using the `binstart` feature of `esp-idf-sys`, always keep this module imported
use log::*;
use max7219::*;
use serde::Serialize;
use std::{
    str,
    sync::{Arc, Mutex},
};

mod led;
use led::{RGB8, WS2812RMT};

mod display;
use display::{DotDisplay, Ticker};

mod wifi;
use wifi::Wifi;

#[toml_cfg::toml_config]
pub struct Config {
    #[default("")]
    wifi_ssid: &'static str,
    #[default("")]
    wifi_psk: &'static str,
}

fn main() -> anyhow::Result<()> {
    // It is necessary to call this function once. Otherwise some patches to the runtime
    // implemented by esp-idf-sys might not link properly. See https://github.com/esp-rs/esp-idf-template/issues/71
    esp_idf_sys::link_patches();
    // Bind the log crate to the ESP Logging facilities
    esp_idf_svc::log::EspLogger::initialize_default();
    let peripherals = Peripherals::take().unwrap();

    // The constant CONFIG is auto-generated by toml_config
    let app_config = CONFIG;
    let mut led = WS2812RMT::new(peripherals.pins.gpio18, peripherals.rmt.channel0)?;

    led.set_pixel(RGB8::new(50, 50, 0))?; // TODO...

    // Associate to network and obtain DHCP IP
    info!(
        "Loading with credentials, ssid:{:?} psk:{:?}",
        app_config.wifi_ssid, app_config.wifi_psk
    );
    let mut wifi = Wifi::init(
        peripherals.modem,
        &app_config.wifi_ssid,
        &app_config.wifi_psk,
    );
    Wifi::start(&mut wifi)?;

    // Setup for the Ticker display
    let data = PinDriver::output(peripherals.pins.gpio0).unwrap();
    let cs = PinDriver::output(peripherals.pins.gpio1).unwrap();
    let sck = PinDriver::output(peripherals.pins.gpio2).unwrap();
    let ticker_main = Arc::new(Mutex::new(Ticker::new(
        DotDisplay::from(MAX7219::from_pins(1, data, cs, sck).unwrap()).unwrap(),
    )));
    let ticker_message_handler = ticker_main.clone();
    let ticker_brightness_handler = ticker_main.clone();
    ticker_main.lock().unwrap().set_message("Hello world")?;
    ticker_main
        .lock()
        .unwrap()
        .display
        .set_brightness(80)
        .expect("Failed to set brightness");

    let tick_speed_ms = Arc::new(Mutex::new(70 as u64));
    let tick_speed_handler = tick_speed_ms.clone();

    // Set the HTTP server
    let mut server = EspHttpServer::new(&Configuration::default())?;
    server.fn_handler("/", Method::Get, |request| {
        #[derive(Serialize)]
        struct TickerConfig {
            message: String,
            speed: u16,
            brightness: u8,
        }

        let config = TickerConfig {
            speed: 0,
            message: String::default(),
            brightness: 0,
        };
        let mut response = request.into_ok_response()?;
        response.write_all(serde_json::to_string(&config)?.as_bytes())?;
        Ok(())
    })?;

    // Speed
    server.fn_handler("/speed", Method::Put, move |mut req| {
        let len = req.content_len().unwrap_or(0) as usize;
        let mut buf = vec![0; len];
        req.read_exact(&mut buf)?;

        if let Ok(as_str) = str::from_utf8(&buf) {
            if let Ok(speed) = as_str.parse::<u64>() {
                if speed <= 1000 {
                    info!("Set scroll speed to {:?}ms", speed);
                    *tick_speed_handler.lock().unwrap() = speed;
                    req.into_ok_response()?;
                    return Ok(());
                }
            }
        }

        Err(().into())
    })?;

    // Brightness
    server.fn_handler("/brightness", Method::Put, move |mut req| {
        let len = req.content_len().unwrap_or(0) as usize;
        let mut buf = vec![0; len];
        req.read_exact(&mut buf)?;

        if let Ok(as_str) = str::from_utf8(&buf) {
            if let Ok(brightness) = as_str.parse::<u8>() {
                match ticker_brightness_handler
                    .lock()
                    .unwrap()
                    .display
                    .set_brightness(brightness)
                {
                    Ok(_) => {
                        info!("Set brightness to {:?}%", brightness);
                        req.into_ok_response()?;
                        return Ok(());
                    }
                    _ => (), // Fall through
                }
            }
        }

        Err(().into())
    })?;

    // Message
    server.fn_handler("/message", Method::Put, move |mut req| {
        let len = req.content_len().unwrap_or(0) as usize;
        let mut buf = vec![0; len];
        req.read_exact(&mut buf)?;

        if let core::result::Result::Ok(as_str) = str::from_utf8(&buf) {
            ticker_message_handler.lock().unwrap().set_message(as_str)?;
            debug!("Setting ticker message to: {:?}", as_str);
            req.into_ok_response()?;
            return Ok(());
        }

        Err(().into())
    })?;

    let mut seed = 0;
    loop {
        ticker_main.lock().unwrap().tick();

        seed += 1;

        if (seed % 2) == 0 {
            led.set_pixel(RGB8::new(0, 0, 50))?; // Blue
        } else {
            led.set_pixel(RGB8::new(0, 50, 0))?; // Green
        }

        std::thread::sleep(std::time::Duration::from_millis(
            *tick_speed_ms.lock().unwrap(),
        ));
    }
}
